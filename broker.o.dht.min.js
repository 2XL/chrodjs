
// Chenglong Zou
// 19/august/2014
// 8:42AM




var chord = new (function() {

    var idBits = 1; // 3*4 -> 2^12 -> 4092 // CHROD ID BITWISE
    var client;
    var node;
// public methods
    /**
     * Inicialitzar el node amb el bootstraper i el successorNode
     * @param {type} url
     * @param {type} room, nom del chord
     * @returns {undefined}
     */
    this.connect = function(room, url) {
        url = (url === undefined) ? "http://immense-dawn-3659.herokuapp.com/" : url;
        if (document.location.hostname === "localhost") {
            url = "http://localhost:5000";
        }
        var socket = io.connect(url);
        // function that is called onload
        client = new xClient(socket); // establish connection with bootstraper 
        client.connect(room);
        // intervalTimer - ms
        var waitSetupBootNodeTime = 2000;
        var waitSetupJoinChordTime = 3000;
        var stabilizeBootNodeTime = 10000;
        /**
         * wait until bootstrap id is assigned and a booter is found
         * @type type
         */
        var waitSetupBootNode = setInterval(function() {
            if (client.id() === undefined) {
                console.log("Waiting BootNode..." + time());
            } else {
                node = new xNode(socket, client.id(), client.bootId(), idBits); // use bootstraper as relay to join overlay
                console.log("Node and Client ok");
                console.info("Init Setup...  " + time());
                node.setup();
                clearInterval(waitSetupBootNode);
            }
        }, waitSetupBootNodeTime);

        /**
         * wait until a datachannel is established with the successorNode
         * @type type
         */
        var waitSetupJoinChord = setInterval(function() {
            if (node !== undefined && node.isBootReady()) {
                console.log("Waiting dcBootNode..." + time());
            } else {
                console.log("Node and Boot ok");
                console.info("Init Join CHORD... " + time());
                node.join();
                clearInterval(waitSetupJoinChord);
            }
        }, waitSetupJoinChordTime);

        var stabilizeBootNode;
        stabilizeBootNode = setInterval(function() {
            client.bootStrapStatus(); // periodically update booter id
            if (node !== undefined && node.get_dc()[client.bootId()]) {
                if (node.get_dc()[client.bootId()].readyState === "open") {
                    // ok
                } else {
                    console.error("LEADER HAS DC!!!");
                }
            } else if (node.get_dc()[client.bootId()] === undefined) {
                client.reconnect();
            }
        }, stabilizeBootNodeTime);
    };

    this.put = function(value, key) { // max bit hops
        node.put(value, key);
    };

    this.get = function(key) { // max bits hops
        node.get(key);
    };

    this.broadcast = function(msg) {
        node.broadcast(msg);
    };

// status tools -> HIDE ON RELEASE

    this.hash = function() {
        return node.hash();
    };
    this.id = function() {
        return client.id();
    };
    this.readyState = function() { // permetro o no fer put, get, broadcast
        return node.nodeReadyState();
    };



    // //// //
    // NODE ////////////////////////////////////////////////////////////////////
    // //// // Chord node
    function xNode(socket, nodeId, bootId, bitwise) {


        // chord data
        var id = nodeId;
        var boot = bootId;

        var hash = Sha1.digest(id, bitwise);
        var bits = bitwise * 4;
        var range = Math.pow(2, bits);

        var readyState = false; // actualitzar readyState despres de have fet un req de tot els finger.start?


        var pc = [];
        var pc_loopback;
        var dc = [];
        var dc_loopback;


        var predecessor = id;   // set on notify
        var successor;          // this should be removed
        var successorNode; // = id; // node successor d'integracio al chord


        /////////////////////
        // Peer Connection configuration
        var pc_config = {"iceServers": [{"url": "stun:" + webrtcStunServer}]};
        var dc_config = {reliable: true}; // :D
        var ms_config = {mandatory: {OfferToReceiveAudio: false, OfferToReceiveVideo: false}};


        var finger = {}; // 

        var store = {}; // store = merget(store_local, store_transfer);
        var store_list = {}; // replica store

        var income = {}; // memeria on guardo els resultats del get
        var succ_list = {};

        var node_ready = {}; // list of remote ready nodes 
        var node_alive_bypass = 15000; // esborrarlo definitivamnet
        var node_alive = {}; // last alive epoc


        // STARTING
        console.warn("\nNew...\nHash:" + hash + "\nNode:" + id + "\nBoot:" + boot);

        // LOOP BACK TODO 
        establish_peer_connection(id, id);

        //////////////////////
        // PUBLIC CHORD UTILS
        this.put = function(value, key) {
            if (key === undefined || key === "" || key === null || isNaN(key)) {
                key = Sha1.digest(value, bitwise);
            }
            key = parseInt(key);
            key = key % range;
            var msg = {
                type: "lookup", // aixo ja fa lo de buscar closest, buscara el node mateix en m hops 
                rmi: "put", // 
                srcNode: id,
                srcHash: hash,
                tgtNode: undefined, // has to find it
                tgtHash: key,
                key: key,
                value: value,
                msg: "put {key: value}...  {" + key + ": " + value + "}",
                // default -> lookup & loopback utils
                proxyNode: id, // next step intermediary
                proxyStack: [id], // starting with self, afterward push... push
                path: [id], // stack of route taken
                hop: 0
            };
            send(id, msg); // self lookup
        };

        this.get = function(key) {
            if (isNaN(key)) {
                key = Sha1.digest(key, bitwise);
                alert("Key Not a Number!... try: " + key);
            }
            key = parseInt(key);
            key = key % range;
            var msg = {
                type: "lookup", // aixo ja fa lo de buscar closest, buscara el node mateix en m hops 
                rmi: "get", // 
                srcNode: id,
                srcHash: hash,
                tgtNode: undefined, // has to find it
                tgtHash: key,
                key: key,
                value: undefined,
                msg: "get {key:value} ...  {" + key + ":value}",
                // default -> lookup & loopback utils
                proxyNode: id, // next step intermediary
                proxyStack: [id], // starting with self, afterward push... push
                path: [id], // stack of route taken
                hop: 0
            };
            send(id, msg); // self lookup
        };

        this.broadcast = function(msg) {
            for (var key in dc) {
                if (dc[key].readyState === "open")
                    try {
                        send(key, {type: "rmi", rmi: "broadcast", srcNode: id, srcHash: hash, tgtNode: key, msg: msg});
                    } catch (e) {
                        console.error(e.message);
                    }
                else {
                    //   establish_peer_connection(key);
                    console.error("STILL CONNECTING!" + key);
                }
            }
        };

        // Protected
        this.isBootReady = function() {
            try {
                send(boot, "hello booter!");
                return false;
            } catch (e) {
                console.log("booter not connected!");
            }
            return true;
        };

        this.isSuccessorNodeReady = function() {
            try {
                if (successorNode === undefined) {
                    console.log("successor not defined!");
                } else if (dc[successorNode] && dc[successorNode].readyState === "open") {
                    send(successorNode, "hello successor!");
                    return true;
                }
            } catch (e) {
                console.log("successor connecting...");
            }
            return false;
        };

        this.join = function() {
            var waitConnectionToSuccessorTime = 3000;
            var waitSuccessorCandidateTime = 10000;
            console.error("join... \nnode:" + id + "\nboot:" + boot + "\nboot:" + client.bootId());
            if (boot !== client.bootId()) {
                boot = client.bootId();
            }
            if (id !== boot) { // if boot is not my self, i have to search for a successor 
                var intent = 0;
                var waitSuccessorCandidate = setInterval(function() {
                    if (successorNode !== undefined) {
                        intent++;
                        console.log("pendingSuccessor candidate... " + intent);
                        if (dc[successorNode] || dc[successorNode] === "open") {
                            console.log("conection already established");
                            clearInterval(waitSuccessorCandidate);
                        } else {
                            // after knowing successor, connect to successor
                            console.error("CONNECTING WITH succesorNode");
                            establish_peer_connection(successorNode, boot);
                        }
                    } else {
                        console.log("Successor still undefined!");

                        find_successor(hash, client.bootId()); // find successor of my hash
                    }
                }, waitSuccessorCandidateTime);
                var waitConnectionToSuccessor = setInterval(function() {
                    if (successorNode && dc[successorNode] && dc[successorNode].readyState === "open") {
                        console.error("connectionSucceed with successor");
                        console.info("Setup_STABILIZE_CHORD");
                        init_finger_table(successorNode);
                        clearInterval(waitConnectionToSuccessor);
                    } else {
                        console.log("pendingConnection with successor");
                    }

                }, waitConnectionToSuccessorTime);

            } else {
                console.log("finger | pred | succ | 'self'");
                for (var i = 0; i < bits; i++) {
                    finger[i] = {};
                    finger[i].start = (hash + Math.pow(2, i)) % range;
                    finger[i].finish = (hash + Math.pow(2, i + 1)) % range;
                    finger[i].hash = hash;
                    finger[i].node = id;
                    // declaration & setup & interval timer
                }
                successor = finger[0].node; //
                predecessor = id;
                readyState = true;
                node_ready[id] = true;
                keepAlive(id);
                console.info("Setup_STABILIZE_CHORD");
                stabilize(); // timeout
            }
        };


        // debug PER ESBORRAR
        this.hash = function() {
            return hash;
        };
        this.nodeReadyState = function() {
            return readyState;
        };
        this.get_dc = function() {
            return dc;
        };

        ////////////////////////
        // RMI CHORD UTILS

        /**
         * get a hash successor
         * @param {Integer} tgtHash
         * @param {String} proxyNode 
         * @returns {undefined}
         */
        function find_successor(tgtHash, proxyNode) { // isHash true -> tgtHash: hash ; false || undefined
            var msg = {
                type: "lookup", // aixo ja fa lo de buscar closest, buscara el node mateix en m hops 
                rmi: "find_successor", // 
                srcNode: id,
                srcHash: hash,
                tgtNode: undefined, // has to find it
                tgtHash: tgtHash,
                match: false,
                msg: "findSuccessor... I [" + id + "]:[" + hash + "] want to find successor of [" + tgtHash + "]",
                // default -> lookup & loopback utils
                proxyNode: proxyNode, // next step intermediary
                proxyStack: [id], // starting with self, afterward push... push
                path: [id], // stack of route taken
                hop: 0
                        // particular 
            };
            console.error("SEND RMI_FIND_SUCC REQUEST!!!!!!!!!!!!");
            send(proxyNode, msg);
        }

        /**
         * 
         * @param {String} tgtNode
         * @returns {undefined}
         */
        function init_finger_table(tgtNode) {
            console.log("INIT_FINGER_TABLE");
            var tgtHash = Sha1.digest(tgtNode, bitwise);
            var msg = {
                type: "rmi", // aixo ja fa lo de buscar closest, buscara el node mateix en m hops 
                rmi: "init_finger_table", // 
                srcNode: id,
                srcHash: hash,
                tgtNode: tgtNode, // has to find it
                tgtHash: tgtHash,
                msg: "initFingerTable... I [" + id + "]:[" + hash + "] want to learn your fingers [" + tgtHash + "]",
                // default -> lookup & loopback utils
                proxyNode: tgtNode, // next step intermediary
                proxyStack: [id], // starting with self, afterward push... push
                path: [id], // stack of route taken
                hop: 0
            };
            send(tgtNode, msg);
        }

        /**
         * UPDATE all nodes whose finger tables should refer to n
         * @returns {undefined}
         */
        function update_others() {
            console.log("UPDATE_OTHERS");
            var msg = {
                type: "lookup", // aixo ja fa lo de buscar closest, buscara el node mateix en m hops 
                rmi: "update_others", // 
                srcNode: id,
                srcHash: hash,
                tgtNode: undefined, // has to find it
                tgtHash: undefined, // actualitza a cada bucle
                index: undefined, // actualiztza a cada bucle
                msg: "Update your finger table with me!",
                // default -> lookup & loopback utils
                proxyNode: id, // next step intermediary
                proxyStack: [id], // starting with self, afterward push... push
                path: [id], // stack of route taken
                hop: 0
            };
            var indexInterval;
            for (var i = 0; i < bits; i++) {
                // find last node p whose ith finger might be n                         
                indexInterval = hash - Math.pow(2, i);
                msg.tgtHash = indexInterval < 0 ? indexInterval + range : indexInterval;
                msg.index = i;
                send(msg.proxyNode, msg);
            }


        }

        /**
         * aixo es lo que executara el target node
         * @param {type} msg
         * @returns {undefined}
         */
        function update_finger_table(msg) {
            // s -> msg.srcNode: msg.srcHash
            // i -> msg.index
            if (closer(hash, msg.srcHash, finger[msg.index].hash)) {
                console.log(msg);
                if (msg.index === 0) {
                    successor = msg.srcNode;
                }
                finger[msg.index].node = msg.srcNode;
                finger[msg.index].hash = msg.srcHash;
                return true;        // forward to next predecessor
            } else {
                return false;       // stop backward
            }
        }

        /**
         * fer que el propi node faci cerques periodiques 
         * @param {type} index
         * @param {type} proxyNode
         * @returns {undefined}
         */
        function fix_finger(index, proxyNode) {
            if (proxyNode === undefined) {
                proxyNode = id;
            }
            // funcion 
            //
            if (finger && finger[index]) {
                var msg = {
                    type: "lookup",
                    rmi: "fix_finger",
                    srcNode: id,
                    srcHash: hash,
                    tgtNode: undefined,
                    tgtHash: finger[index].start,
                    msg: "Do you know anyone closer than my current finger?", // looking for this key predecessor o itself
                    proxyNode: proxyNode,
                    proxyStack: [id],
                    path: [id],
                    hop: 0,
                    index: index,
                    current: finger[index]
                };

                send(msg.proxyNode, msg);
            }


        }


        ////////////////////
        // CHORD STABILIZE
        function stabilize() {
            console.info(">>>> STABILIZE <<<<");

            var stabilize_successor; // comprovar si el successor encara esta viu
            var stabilize_dc; // per esborrar entrades de dc inactives del finger o indicar activitat
            var stabilize_predecessor; // comprovar si el successor encara esta viu, per actualizar | transferencia de claus
            var stabilize_successor_list;   // per replicacio de claus  
            var stabilize_fix_fingers;    // fer un lookup del start d'un finger

            var stabilize_successor_time = 10000;
            var stabilize_dc_time = 5000; // perque doni temps per establir connexions inicials del finger table abans de esborrar!
            var stabilize_predecessor_time = 4000; // por consistencia tiene que ser menor que el stabilize successor
            var stabilize_successor_list_time = 10000;
            var stabilize_fix_fingers_time = 7000;   // poc costos | no funciona .... 


            // 
            // FIX FINGERS
            // periodically refresh finger table entries
            var currentFinger = 0;
            stabilize_fix_fingers = setInterval(function() {  // // fer keep alive !!!! 
                fix_finger(currentFinger);
                currentFinger++;
                currentFinger = currentFinger % bits;
            }, stabilize_fix_fingers_time);

            //
            // CHECK DATACHANNEL // RANDOM
            // 
            stabilize_dc = setInterval(function() {
                // get random number and check its status 
                // MUUU MAL :D
                var msg;
                var key;
                //  for (var index in finger) {
                //    key = finger[index].node;
                for (key in dc) {
                    if (dc[key] && dc[key].readyState === "open") {
                        if (key !== id) {
                            if (stillAlive(key)) {
                                msg = {
                                    type: "rmi",
                                    rmi: "keep_alive",
                                    srcNode: id,
                                    srcHash: hash,
                                    tgtNode: key,
                                    tgtHash: Sha1.digest(key, bitwise),
                                    msg: "stabilize_dc: hi " + key + " im " + id + " ...",
                                    proxyNode: key,
                                    proxyStack: [id],
                                    path: [id],
                                    hop: 0
                                };
                                send(key, msg);
                            }
                        } else {
                            node_ready[id] = true;
                        }
                    } else {
                        //  stillAlive(key);
                        //   if (!deathlocker(id, key)) {
                        if (stillAlive(key)) {
                            establish_peer_connection(key);
                        } else {

                        }
                    }
                }


                if (dc[id] === undefined) {
                    establish_peer_connection(id, id);
                }

            }, stabilize_dc_time);

            //
            // CHECK SUCCESSOR, ESTA REPLICAT DEL FIX FINGER
            //
            // stabilize_successor
            stabilize_successor = setInterval(function() { // stabilize, periodically check inmdiate successor state & tell him about me
                if (finger && finger[0]) {
                    console.log("STABILIZE_SUCCESSOR_PREDECESSOR");
                    if (finger[0].node !== id) {
                        if (node_ready[finger[0].node]) {
                            var msg;
                            msg = {
                                type: "rmi",
                                rmi: "stabilize_successor",
                                srcNode: id,
                                srcHash: hash,
                                tgtNode: finger[0].node,
                                tgtHash: finger[0].hash,
                                msg: "stabilize_successor: hi " + successor + " im " + id + " ...",
                                proxyNode: finger[0].node,
                                proxyStack: [id],
                                path: [id],
                                hop: 0
                            };
                            send(finger[0].node, msg);
                        }
                    }
                }

                if (node_ready[successor] === false || node_ready[successor] === undefined) {
                    // ja s'encarrega el fix fingers 
                    if (succ_list[0] !== undefined) {
                        cand = succ_list.shift();

                    } else {
                    }
                }


                // fer replicació del successor list
            }, stabilize_successor_time);

            //
            // LOOKUP FOR SUCCESSOR LIST
            //
            var succ_list_replicas = bitwise;
            stabilize_successor_list = setInterval(function() {
                if (finger && finger[0]) {
                    console.log("STABILIZE_SUCCESSOR_LIST_ALIVE");
                    if (finger[0].node !== id) {    // succ not myself :D
                        var msg;
                        msg = {
                            type: "rmi",
                            rmi: "stabilize_successor_list", //
                            srcNode: id,
                            srcHash: hash,
                            tgtNode: finger[0].node,
                            tgtHash: finger[0].hash,
                            msg: "stabilize_successor_list: hi " + successor + " im " + id + " ...",
                            proxyNode: finger[0].node,
                            proxyStack: [id],
                            path: [id],
                            list: [], // succ_list
                            replica: succ_list_replicas, //  if hop < replica, the target node will replicate my keyset
                            store: store,
                            hop: 0
                        };
                        send(finger[0].node, msg);
                    }
                }
            }, stabilize_successor_list_time);

            //
            // CHECK PREDECESSOR
            // 
            stabilize_predecessor = setInterval(function() {
                // notify if predecessor  dc or not correct
                // key transfer and key manipulation
                // sendMessage to predecessor
                if (predecessor !== id) { // jo soc el meu predecessor mes llunya
                    var predHash = Sha1.digest(predecessor, bitwise);
                    var store_transfer = splitStore(predecessor);
                    var msg = {
                        type: "rmi",
                        rmi: "stabilize_predecessor", //
                        srcNode: id,
                        srcHash: hash,
                        tgtNode: predecessor,
                        tgtHash: predHash,
                        msg: "stabilize_predecessor: hi " + predecessor + " im " + id + " ...",
                        proxyNode: predecessor,
                        transfer: store_transfer,
                        proxyStack: [id],
                        path: [id],
                        hop: 0
                    };
                    if (node_ready[predecessor]) {
                        send(predecessor, msg);
                    } else {
                        if (store_list[predecessor] !== undefined) {
                            console.log("predecessor merge!");
                            store = merge(store, store_list[predecessor]);
                            delete store_list[predecessor];
                            predecessor = id;
                        }
                    }
                }
            }, stabilize_predecessor_time);

        }



//////////////////////////////
// REMOTE PROCEDURE HANDLERS 
        function handle_rpc(msg) {
            switch (msg.type) {
                case "closest_finger_preceding_node": // return closest finger <= id
                case "lookup":  // ------> ----> ---> --> -> // lst hop is type rmi --> hasta el nodo que guarda la clave
                    if (hash === msg.tgtHash) { // found targetNode!
                        console.log("TARGET FOUND FOR: " + msg.tgtHash + " : ME : " + id + "[" + hash + "]");
                        handle_rmi(msg);    // localhost
                    } else { // next hop forward // max hops will be index || ir surpass bitwise then return error
                        var next;
                        next = handle_next(msg.tgtHash, 0); // closest preceding node   
                        if (next === id) {  // im the closest preceding :D
                            handle_rmi(msg); // too much steps
                        } else { // forward th next
                            msg.path.push(msg.proxyNode);
                            msg.proxyStack.push(msg.proxyNode);
                            msg.proxyNode = next;
                            msg.hop += 1;
                            send(next, msg);
                        }
                    }
                    break;
                case "loopback": // <----- <---- <--- <-- <- // lst hop is type rmi 
                    if (msg.proxyNode === msg.tgtNode) { // ja estem al tgtNode
                        handle_rmi(msg);
                    } else {
                        msg.path.push(id);
                        msg.proxyNode = msg.proxyStack.pop();
                        msg.hop -= 1;
                        send(msg.proxyNode, msg);
                    }
                    break;
                case "rmi": // cas single hop retorn hop
                    handle_rmi(msg);
                    break;
                default:
                    console.log(msg.type);
                    console.log("type not defined!");
                    break;
            }
        }

        function handle_next(tgtHash, hop) {
            var keys = new Array();
            for (var key in finger) {
                keys.unshift(key);
            }
            var ini;
            var fin;
            var cand;
            for (var i = hop; i < keys.length; i++) {
                ini = finger[keys[i]].start;
                fin = finger[keys[i]].finish;
                cand = finger[keys[i]].hash;
                if (closer(tgtHash, hash, cand) && stillAlive(finger[keys[i]].hash)) // target hash is 
                {
                    return finger[keys[i]].node;
                }
            }
            return id;
        }

        function handle_rmi(msg) { // condicions y funcions
            keepAlive(msg.srcNode);
            switch (msg.rmi) {
                case "closest_preceding":
                    break;
                case "establish":
                    if (msg.type === "lookup") { // tractament req
                        handleEstablishReq(msg);
                    } else if (msg.type === "loopback") { // tractament res
                        handleEstablishRes(msg);
                    }
                    break;

                case "find_successor":
                    if (msg.type === "lookup") { // tractament req
                        handleFindSuccessorReq(msg);
                    } else if (msg.type === "loopback") { // tractament res
                        handleFindSuccessorRes(msg);
                    }
                    break;

                case "update_others":
                    if (msg.type === "lookup") { // update_others
                        // primer ---
                        handleUpdateFingerTable(msg);
                    } else if (msg.type === "rmi") { // update_finger_table
                        // successius ---
                        handleUpdateFingerTable(msg);
                    } else if (msg.type === "loopback") {
                    }
                    break;

                case "init_finger_table":
                    if (msg.tgtNode === msg.proxyNode) { // tractament req
                        handleInitFingerTableReq(msg);
                    } else {
                        handleInitFingerTableRes(msg);
                    }
                    break;

                case "stabilize_successor":
                    if (msg.type === "rmi") {
                        stabilizeSuccessorReq(msg);
                    } else if (msg.type === "loopback") { // tractament res
                        stabilizeSuccessorRes(msg);
                    }
                    break;

                case "stabilize_successor_list":
                    if (msg.type === "rmi") {
                        stabilizeSuccListReq(msg); // fer la replica
                        stabilizeSuccListForward(msg);
                    } else if (msg.type === "loopback") { // send to successor
                        stabilizeSuccListRes(msg); // srcNode :D
                    }
                    break;

                case "stabilize_predecessor":
                    if (msg.type === "rmi") {
                        stabilizePredecessorReq(msg);
                    } else if (msg.type === "loopback") {
                        stabilizePredecessorRes(msg);
                    }
                    break;

                case "stabilize_finger":
                    if (msg.type === "rmi") { // tractament req
                        stabilizeFingerTableReq(msg);
                    } else if (msg.type === "loopback") { // tractament res
                        stabilizeFingerTableRes(msg);
                    }
                    break;

                case "fix_finger": // TODO
                    //     console.log(msg);
                    if (msg.type === "lookup") { // tractament req
                        handle_fixFingerReq(msg); // busco el predecessor de finger[#].start
                    } else if (msg.type === "rmi") { // destinatari del msg
                        handle_fixFinger(msg); // trobat o successor
                    } else if (msg.type === "loopback") { // tractament res
                        handle_fixFingerRes(msg); // retorna origen per actualitzar
                    }
                    break;

                case "put":
                    if (msg.type === "lookup") { // tractament req                       
                        handle_putReq(msg);
                    } else if (msg.type === "rmi") { // destinatari del msg
                        handle_put(msg);
                    } else if (msg.type === "loopback") { // tractament res
                        handle_putRes(msg);
                    }
                    break;

                case "get":
                    if (msg.type === "lookup") { // tractament req
                        handle_getReq(msg);
                    } else if (msg.type === "rmi") { // destinatari del msg
                        handle_get(msg);
                    } else if (msg.type === "loopback") { // tractament res
                        handle_getRes(msg);
                    }
                    break;

                case "message":
                case "broadcast":
                    console.log(msg.srcNode + " >> " + msg.msg);
                    //      alert(msg.msg);
                    break;

                case "keep_alive":
                    if (msg.tgtNode === msg.proxyNode) { // tractament req
                        stabilizeKeepAliveReq(msg);
                    } else { // tractament res
                        stabilizeKeepAliveRes(msg);
                    }
                    break;

                default:
                    console.log(msg.rmi);
                    console.log("rmi not defined! " + msg.rmi);
                    break;
            }
        }

// STABILIZE HANLERS
        function stabilizeSuccessorReq(msg) {
            if (msg.srcNode === predecessor) {
                msg.msg = "Yes, im still your predecessor!"; // yea we already know each other 
            } else {
                if (node_ready[predecessor] === undefined) {
                } else {
                    if (closer(Sha1.digest(predecessor, bitwise), msg.srcHash, hash)) // mirar si el emisor podria ser el meu predecessor
                    {
                        msg.msg = "Yes, you are my new predecessor!"; // handle key transfer to response
                        predecessor = msg.srcNode;
                    } else {
                        msg.msg = "No, your successor may be --> " + predecessor;
                    }
                }
            }
            msg.type = "loopback";
            msg.tgtHash = msg.srcHash;
            msg.tgtNode = msg.srcNode;
            msg.srcNode = id;
            msg.srcHash = hash;
            msg.succ = predecessor;
            msg.proxyNode = msg.tgtNode;
            send(msg.proxyNode, msg);
        }

        function stabilizeSuccessorRes(msg) {
            if (msg.succ === id) {
                keepAlive(msg.srcNode);
            } else { // no cal fer res per que aixo ja ho fa el fix.fingers
                if (node_ready[msg.succ] || ((dc[msg.succ] && dc[msg.succ] === "open"))) {
                    finger[0].node = msg.succ;
                    finger[0].hash = Sha1.digest(msg.succ, bitwise);
                    successor = msg.succ;
                } else {
                    establish_peer_connection(msg.succ, msg.srcNode);
                }
            }
        }

        function stabilizeFingerTableReq(msg) {
            var distCurr = distance(msg.current.start, msg.current.hash) % range;
            var distCand;
            var currNode = msg.current.node;
            var currHash = msg.current.hash;
            var candHash; // hash
            var hasCloser = false;
            for (var key in dc) {
                if (dc[key].readyState === "open" && node_ready[key] === true) {
                    candHash = Sha1.digest(key, bitwise);
                    distCand = distance(msg.current.start, candHash) % range;
                    if (distCand < distCurr) {
                        currNode = key;
                        currHash = candHash;
                        distCurr = distCand;
                        hasCloser = true;
                    }
                }
            }
            var candidate = msg.current;
            candidate.node = currNode;
            candidate.hash = currHash;
            msg.type = "loopback";
            msg.hasCloser = hasCloser;
            msg.tgtNode = msg.srcNode;
            msg.tgtHash = msg.srcHash;
            msg.srcNode = id;
            msg.srcHash = hash;
            msg.proxyNode = msg.tgtNode;
            msg.msg = "Possible closer finger..." + hasCloser;
            msg.candidate = candidate;
            send(msg.proxyNode, msg);
        }

        function stabilizeFingerTableRes(msg) {
            if (msg.hasCloser) {
                if (node_ready[msg.candidate.node] || ((dc[msg.candidate.node] && dc[msg.candidate.node] === "open"))) {
                    try {
                        send(msg.candidate.node, {type: "rmi", rmi: "message", msg: "You're my new finger! " + msg.index});
                        finger[msg.index] = msg.candidate;
                        if (msg.index === 0)
                        {
                            successor = finger[msg.index].node; // la distancia ja esta comprovada en el remote node
                        }
                    } catch (e) {
                        // nothing happens
                        // 
                    }
                } else {
                    establish_peer_connection(msg.candidate.node, msg.srcNode);
                }
            } else {

            }
        }

        function stabilizeKeepAliveReq(msg) {
            msg.tgtNode = msg.srcNode;
            msg.tgtHash = msg.srcHash;
            msg.srcNode = id;
            msg.srcHash = hash;
            msg.msg = "My ready State... " + readyState;
            msg.readyState = readyState;
            send(msg.tgtNode, msg);
        }

        function stabilizeKeepAliveRes(msg) {
            var readyBefore = node_ready[msg.srcNode];
            node_ready[msg.srcNode] = msg.readyState;
            keepAlive(msg.srcNode);
            if (msg.readyState === false && readyBefore) {
            }
        }

        function stabilizePredecessorReq(msg) {
            if (msg.srcNode === successor) {
                msg.update = true;
                store = merge(store, msg.transfer);
            } else {
                if (closer(finger[0].hash, msg.srcHash, hash)) {
                    msg.update = false;
                    msg.msg = "you are my new successor!";
                } else {
                    msg.update = false;
                    msg.msg = "my successor: " + successor;
                }
            }
            msg.type = "loopback";
            msg.tgtNode = msg.srcNode;
            msg.tgtHash = msg.srcHash;
            msg.srcNode = id;
            msg.srcHash = hash;
            send(msg.proxyNode, msg);
        }

        function stabilizePredecessorRes(msg) {
            if (msg.update)
            {
                splitStore(msg.srcNode, true);
            } else { // don't split ...
            }
        }

        function stabilizeSuccListReq(msg) {
            // fer la replica is cal 
            if (msg.hop < msg.replica) {
                store_list[msg.srcNode] = msg.store;
            }
        }
        function stabilizeSuccListForward(msg) {
            msg.list[msg.hop] = {id: id, hash: hash}; // el meu successor ha d'estar en la llista !
            if (closer(hash, finger[0].hash, msg.srcHash) && msg.srcHash !== msg.tgtN !== finger[0]) {// msg.type = loopback 
                msg.path.push(msg.proxyNode);
                msg.proxyStack.push(msg.proxyNode);
                msg.proxyNode = finger[0].node;
                msg.hop += 1;
            } else { // aixi no incloc el me predecessor,
                msg.type = "loopback";
                msg.tgtNode = msg.srcNode;
                msg.tgtHash = msg.srcHash;
            }
            send(msg.proxyNode, msg);
        }
        function stabilizeSuccListRes(msg) { // loopback enlloc de forward per assegurarnos, que almenys les connexions estan obertes
            succ_list = msg.list;
        }


// RMI HANDLERS
//

        function handle_fixFingerReq(msg) {
            var next;
            if (msg.tgtHash === hash) { // jo mateix so el start
                handle_fixFinger(msg);
            } else { // el start no soc jo mateix pertant el meu succesor seria el més proper!
                next = successor;
                msg.type = "rmi";
                msg.path.push(msg.proxyNode);
                msg.proxyStack.push(msg.proxyNode);
                msg.proxyNode = next;
                msg.hop += 1;
                send(next, msg);
            }
        }
        function handle_fixFinger(msg) { //              
            var candidate = msg.current;
            candidate.node = id;
            candidate.hash = hash;
            msg.candidate = candidate;
            msg.type = "loopback";
            msg.tgtNode = msg.srcNode;
            msg.tgtHash = msg.srcHash;
            msg.srcNode = id;
            msg.srcHash = hash;
            msg.msg = "I " + id + "[" + hash + "] am candidate as your finger: " + msg.index;
            send(msg.proxyNode, msg);
        }


        function handle_fixFingerRes(msg) {
            if (node_ready[msg.candidate.node] || ((dc[msg.candidate.node] && dc[msg.candidate.node] === "open"))) {
                finger[msg.index] = msg.candidate;
                if (msg.index === 0)
                {
                    successor = finger[msg.index].node; // la distancia ja esta comprovada en el remote node
                }
            } else {
                establish_peer_connection(msg.candidate.node);
            }
        }


        function handle_putReq(msg) {
            var next;
            if (msg.key === hash) {
                handle_put(msg);
            } else {
                next = successor;
                msg.type = "rmi";
                msg.path.push(msg.proxyNode);
                msg.proxyStack.push(msg.proxyNode);
                msg.proxyNode = next;
                msg.hop += 1;
                send(next, msg);
            }
        }

        function handle_put(msg) {
            store[msg.key] = msg.value;
            msg.type = "loopback";
            msg.tgtNode = msg.srcNode;
            msg.tgtHash = msg.srcHash;
            msg.srcNode = id;
            msg.srcHash = hash;
            msg.msg = "I " + id + "[" + hash + "] have stored: {key:value} " + msg.key + ":" + msg.value;
            send(msg.proxyNode, msg);
        }
        function handle_putRes(msg) {
            console.log(msg.msg);
        }

        function handle_getReq(msg) {
            var next;
            if (msg.key === hash) {
                handle_get(msg);
            } else {
                next = successor;
                msg.type = "rmi";
                msg.path.push(msg.proxyNode);
                msg.proxyStack.push(msg.proxyNode);
                msg.proxyNode = next;
                msg.hop += 1;
                send(next, msg);
            }

        }
        function handle_get(msg) {
            if (store[msg.key] !== undefined) {
                msg.value = store[msg.key];
                msg.msg = "I " + id + "[" + hash + "] have stored: {key:value} " + msg.key + ":" + msg.value;
            } else {
                msg.msg = "I " + id + "[" + hash + "] don't have value for the key:   [" + msg.key + "]";
            }
            msg.type = "loopback";
            // invertir esto SIEMPRE!!!
            msg.tgtNode = msg.srcNode;
            msg.tgtHash = msg.srcHash;
            msg.srcNode = id;
            msg.srcHash = hash;
            // resultados del query 
            send(msg.proxyNode, msg);
        }
        function handle_getRes(msg) {
            income[msg.key] = msg.value;
        }
//
        function handleEstablishReq(msg) {
            handle_peer_offerResponse(msg); // handle it un sempre llegeix  laltre no
        }
        function handleEstablishRes(msg) {
            handle_peer_answerResponse(msg);
        }
//
        function handleFindSuccessorReq(msg) {
            msg.type = "loopback";
            if (id === msg.srcNode) {
                msg.match = true;
            }
            msg.tgtNode = msg.srcNode;
            msg.tgtHash = msg.srcHash;
            msg.srcNode = id;
            msg.srcHash = hash;
            // resultados del query
            msg.succNode = finger[0].node;
            msg.succHash = finger[0].hash;
            msg.msg = "findSuccessor... My [" + id + "]:[" + hash + "] successor is [" + msg.succNode + "]:[" + msg.succHash + "]";
            send(msg.proxyNode, msg);
        }
        function handleFindSuccessorRes(msg) { // successorNode        
            if (msg.match || successorNode === id) {
                alert("HASH ALREADY EXIST!!!! please refresh the page so new id can be assigned!");
            } else {
                successorNode = msg.succNode;
            }
        }

        function handleInitFingerTableReq(msg) {
            // el successor node genera un finger table virtual per el requester
            var waitFinger = setInterval(function() {
                if (finger[0] !== undefined && dc[msg.srcNode] && dc[msg.srcNode].readyState === "open") {
                    msg.finger = finger;
                    msg.predNode = predecessor;
                    msg.tgtNode = msg.srcNode;
                    msg.tgtHash = msg.srcHash;
                    msg.srcNode = id;
                    msg.srcHash = hash;
                    send(msg.tgtNode, msg);
                    clearInterval(waitFinger);
                } else {
                    console.log("waitFinger ");
                }
            }, 2000);
        }
        function handleInitFingerTableRes(msg) {
            // incialitzar els intervals del finger table
            console.info(msg.finger);
            for (var i = 0; i < bits; i++) {
                finger[i] = {};
                finger[i].start = (hash + Math.pow(2, i)) % range;
                finger[i].finish = (hash + Math.pow(2, i + 1)) % range;
            }

            var nodeCand = msg.srcNode;
            var hashCand = msg.srcHash;
            var j = 0, fingCand = 0;
            console.log("> waitFinger... " + j);
            do { // inicial
                if (closer(msg.srcHash, hash, finger[j].start)) {
                    finger[j].hash = hashCand;
                    finger[j].node = nodeCand;
                    j++;
                } else {
                    hashCand = msg.finger[fingCand].hash;
                    nodeCand = msg.finger[fingCand].node;
                    fingCand++;
                }
            } while ((j < (bits)) && (fingCand < (bits)));

            while (j < bits) {
                finger[j].hash = hash;
                finger[j].node = id;
                j++;
            }
            // AQUI CALL INTERVAL TIMMER ABANS DE INSTANCIAR EL STABILIZE                                  
            console.log(">> FINGER STEADY!"); // despres d'haver cridat tots els fix fingers
            var readyIndex = 0; //ready index desde 0 fins a bits, recorrent tot el fingertable             
            var currNode;
            var waitFingerReady = setInterval(function() {
                if (readyIndex < bits) {
                    currNode = finger[readyIndex].node;
                    if (dc[currNode] && dc[currNode].readyState === "open") {
                        readyIndex++;
                    } else {
                        establish_peer_connection(currNode, msg.srcNode);
                    }
                } else {
                    predecessor = msg.predNode;
                    successor = msg.srcNode;
                    console.log(">> FINGER READY"); // despres de haver establert peer connection amb tots els fingers de la taula amb el bootnode com a intermediari
                    readyState = true;
                    node_ready[id] = true;
                    update_others();
                    stabilize();
                    clearInterval(waitFingerReady);
                }
            }, 1000);
        }
        function handleUpdateFingerTable(msg) {
            if (update_finger_table(msg)) {
                msg.type = "rmi";
                msg.proxyNode = predecessor;
                send(msg.proxyNode, msg);
            } else {
                // nothing more
            }
        }

        // UTILITY FUNCS
        /**
         * send message to specific datachannel(node)
         * @param {type} node
         * @param {type} msg
         * @returns {undefined}
         */
        function send(node, msg) {  // enviar missatge a un node        
            stillAlive(node);
            if (dc[node] !== undefined) {
                if (dc[node].readyState === "open") {
                    try {
                        dc[node].send(JSON.stringify(msg));
                    } catch (e) {
                        console.error(e.message);
                        node_ready[node] = false;
                    }
                } else {
                    // still connecting
                    // initerval timer for connecting again // with 3 intents if failed then this is broken
                    node_ready[node] = false;
                    console.error("CoNeCTiNG... " + node);
                }
            } else {
                if (node !== id) {
                    console.error("NoDe UnknoWn... a DC connection with " + node + " is needed!");
                    node_ready[node] = false;
                }
            }
        }

        /**
         * clockwise distance between nodes, hashSrc -> hashTgt
         * @param {type} hashSrc  - iniNode hash
         * @param {type} hashTgt  - finNode hash
         * @param {type} hashRange
         * @returns {undefined} // return a value inner the hashRange 
         */
        function distance(hashSrc, hashTgt, hashRange) { // hashed
            if (hashRange === undefined) {
                hashRange = range;
            }
            if (hashTgt > hashSrc) {    // me to myself  distance = range
                return hashTgt - hashSrc;
            } else if (hashTgt === hashSrc) {
                return hashRange;
            } else {
                return (hashTgt + hashRange) - hashSrc;
            }
        }

        /**
         * check if:  hashSrc < hashCand < hashSucc  isTRUE // clockwise
         * @param {type} hashSrc
         * @param {type} hashCand
         * @param {type} hashSucc
         * @param {type} hashRange
         * @returns {Boolean}
         */
        function closer(hashSrc, hashCand, hashSucc, hashRange) {
            if (hashRange === undefined) {
                hashRange = range;
            }
            var distSrc = distance(hashSrc, hashSucc, hashRange); // id --> succ 
            var distCand = distance(hashCand, hashSucc, hashRange); // cand --> succ
            return (distCand < distSrc); // if candidate is closer than i do otherwise he dont 
        }

        function deathlocker(srcNode, tgtNode) {
            var hash1;
            var hash2;
            var send;
            hash1 = Sha1.digest(srcNode, bitwise);
            hash2 = Sha1.digest(tgtNode, bitwise);
            console.error("DEADLOCK!");
            if ((hash1 & hash2) % 2) { // 50% de que cada
                // deixar passar un dels dos
                if (hash1 < hash2) {
                    console.error(id + " SRCNODE GOT PRORITY!");
                    send = true;
                } else {
                    send = false;
                }
            } else {
                if (hash1 > hash2) {
                    console.error(id + " TGTNODE GOT PRORITY!");
                    send = true;
                } else {
                    send = false;
                }
            }
            console.log(srcNode + " : " + tgtNode);
            console.error(send);
            return send;
            // els dos poden fer un request pero només un ha de ser el leader 
            // abraçada mortal error 
        }
        /**
         * Merges two (or more) objects, giving the last one precedence
         * src: [https://gist.github.com/svlasov-gists/2383751]
         * @param {type} target
         * @param {type} source
         * @returns 
         */
        function merge(target, source) {
            if (typeof target !== 'object') {
                target = {};
            }
            for (var property in source) {
                if (source.hasOwnProperty(property)) {
                    var sourceProperty = source[ property ];
                    if (typeof sourceProperty === 'object') {
                        target[ property ] = util.merge(target[ property ], sourceProperty);
                        continue;
                    }
                    target[ property ] = sourceProperty;
                }
            }
            for (var a = 2, l = arguments.length; a < l; a++) {
                merge(target, arguments[a]);
            }
            return target;
        }

        // RETURN remote store{{keys:value}} 
        function splitStore(predecessor, commit) {
            var store_local = {}; // local
            var store_transfer = {}; // transfer
            var predHash = Sha1.digest(predecessor, bitwise);
            var index = predHash;
            for (var key in store) { // clone
                store_transfer[key] = store[key];
            }
            var posicion;
            while (index % range !== hash) {
                index = index + 1;
                posicion = index % range;
                if (store[posicion] === undefined) {
                } else {
                    //    console.log("local:: me <- key  __ " + hash + " <- " + index + " ");
                    store_local[posicion] = store_transfer[posicion];
                    delete store_transfer[posicion];
                }
            }
            //  console.log("storeLocal & storeRemote -> " + JSON.stringify(store_local) + " < " + JSON.stringify(store_transfer));
            if (commit) {
                store = store_local;
            }
            return store_transfer;
        }
        function keepAlive(node) {
            if (node !== id && dc[node] && dc[node].readyState === "open")
            {
                node_ready[node] = true;
            }
            node_alive[node] = (new Date).getTime() + node_alive_bypass;
        }
        function stillAlive(node) {  // per actualizar el node_ready      
            if (node_alive[node] < (new Date).getTime()) {
                var nextNode = id;
                var nextHash = hash;
                for (var i = (bits - 1); i >= 0; i--) {
                    if (finger[i].node === node) {
                        finger[i].node = nextNode;
                        finger[i].hash = nextHash;
                        if (i === 0) {
                            successor = nextNode;
                        }
                    } else {
                        nextNode = finger[i].node;
                        nextHash = finger[i].hash;
                    }
                }
                dc[node].close();
                delete dc[node];
                pc[node].close();
                delete pc[node];
                delete node_alive[node];
                delete node_ready[node];

                return false;
            } else {
                return true;
            }
        }


///////////////////////////////////////////////////////////////
// JOIN NODO TO ANOTHER NODE with an proxy node from the chord finger
        function establish_peer_connection(tgtNode, proxyNode) { // tell proxyNode to introduce me tgtNode
            if (dc[tgtNode] && dc[tgtNode].readyState === "open") {
                return false; // conexion ya establecida
            }
            if (proxyNode === undefined)
            {
                proxyNode = handle_next(tgtNode, 0);
                if (proxyNode === id) {
                    if (dc[successor] && (dc[successor].readyState === "open")) {
                        proxyNode = successor;
                    } else if (dc[boot] && (dc[boot].readyState === "open")) {
                        proxyNode = boot;
                    } else if (dc[successorNode] && (dc[successorNode].readyState === "open")) {
                        proxyNode = successorNode;
                    } else {
                        return false; // sin candidato para proxyNode 
                    }
                }
            }
            console.info("ESTABLISH_PEER_CONNECTION: between me:  " + id + "[" + hash + "]---> " + proxyNode + "[" + Sha1.digest(proxyNode, bitwise) + "] ---> " + tgtNode + "[" + Sha1.digest(tgtNode, bitwise) + "]");
            console.log(" ");

            if (tgtNode === proxyNode) { // localhost
                pc_loopback = new RTCPeerConnection(pc_config);
                setPcLoopback();
                setDcLoopback(dc_config, hash);
                pc_loopback.createOffer(gotLocalOffer, gotError, ms_config);
            } else {
                if (pc[tgtNode] === undefined) { // si tinc prioritat sempre podre crear un altre, per reconectar, en cas contrari si sh'ha perdut i no em busca donçs esta perdut             
                    pc[tgtNode] = new RTCPeerConnection(pc_config);
                    setPcHandlers(tgtNode);
                    setDcHandlers(tgtNode, Sha1.digest(tgtNode, bitwise), dc_config);
                    pc[tgtNode].createOffer(gotLocalOffer, gotError, ms_config);
                } else {
                    stillAlive(tgtNode);
                }
            }
            function gotLocalOffer(sdpOffer) {
                if (tgtNode === proxyNode) { // localhost
                    pc_loopback.setLocalDescription(sdpOffer, gotSetOffer, gotError);
                } else {
                    pc[tgtNode].setLocalDescription(sdpOffer, gotSetOffer, gotError);
                }
            }
            function gotSetOffer() { // wait answer  

                var localOffer;
                var myVar = setInterval(function() {
                    if (pc[tgtNode] && pc[tgtNode].remoteDescription !== undefined) {
                        clearInterval(myVar); // connection already on progress en progress
                    }
                    console.info("TGT NODE : " + tgtNode);
                    console.log(pc[tgtNode]);

                    if ((pc[tgtNode] && (navigator.mozGetUserMedia || pc[tgtNode].iceGatheringState === "complete")) || (tgtNode === id && (navigator.mozGetUserMedia || pc_loopback.iceGatheringState === "complete"))) {
                        localOffer = (tgtNode === id) ? pc_loopback.localDescription : pc[tgtNode].localDescription;
                        var tgtHash = Sha1.digest(tgtNode, bitwise);
                        var msg = {
                            type: "lookup", // aixo ja fa lo de buscar closest, buscara el node mateix en m hops 
                            rmi: "establish", // 
                            srcNode: id,
                            srcHash: hash,
                            tgtNode: tgtNode,
                            tgtHash: tgtHash,
                            msg: "sdpOffer... I [" + id + "]:[" + hash + "] want to connect with [" + tgtNode + "]:[" + tgtHash + "]",
                            // default -> lookup & loopback utils
                            proxyNode: proxyNode, // next step intermediary
                            proxyStack: [id], // starting with self, afterward push... push
                            path: [id], // stack of route taken
                            hop: 0,
                            // particular
                            sdp: localOffer
                        };

                        // send localDescription to remoteNode & wait 
                        if (tgtNode === proxyNode) { // localhost // localhost // o try catch
                            handle_peer_offerResponse(msg);
                        } else {
                            send(proxyNode, msg);
                        }
                        clearInterval(myVar);
                    } else {
                        console.log("waiting iceGatheringState to complete");
                    }
                }, 2000);
            }
        }
        // abraçada MORTAL :D
        function handle_peer_offerResponse(msg) {
            try {
                msg = JSON.parse(msg);
            } catch (e) {
                console.info("LOCAL handle_peer_offerResponse");
            }
            console.log(msg);
            console.error("HANDLE_PEER_OFFERRESPONSE: ");
            console.info("from: >>" + msg.srcNode);
            var handle;
            if (pc[msg.srcNode] === undefined) // no hi ha abraçada mortal
            {
                handle = true;
            } else { // hiha abraçada mortal
                if (deathlocker(msg.srcNode, msg.tgtNode))
                {
                    handle = true;
                } else {
                    handle = false;
                }
            }
            if (handle || (msg.srcNode === msg.tgtNode)) { // dont have priority overwrite local description
                pc[msg.srcNode] = new RTCPeerConnection(pc_config);
                setPcHandlers(msg.srcNode);
                console.error("UPDATE " + msg.srcNode + " REMOTE DESCRIPTION");
                pc[msg.srcNode].setRemoteDescription(new RTCSessionDescription(msg.sdp), gotCreateAnswer, gotError);
                console.log(pc[msg.srcNode].localDescription);
                console.log(pc[msg.srcNode].remoteDescription);
                console.log("PC steady! ");
            } else {  // tinc prioritat no faig res
            }
            function gotCreateAnswer() {
                pc[msg.srcNode].createAnswer(gotLocalAnswer, gotError, {});
            }
            function gotLocalAnswer(sdpAnswer) {
                pc[msg.srcNode].setLocalDescription(sdpAnswer, gotSetAnswer, gotError);
            }
            function gotSetAnswer() {
                var myVar = setInterval(function() {
                    if (pc[msg.srcNode] && (navigator.mozGetUserMedia || pc[msg.srcNode].iceGatheringState === "complete")) {
                        msg = {
                            type: "loopback", // aixo ja fa lo de buscar closest, buscara el node mateix en m hops 
                            rmi: "establish", // 
                            srcNode: msg.tgtNode, //invertir resposta SEMPRE!!!
                            srcHash: msg.tgtHash,
                            tgtNode: msg.srcNode,
                            tgtHash: msg.srcHash,
                            msg: "sdpAnswer... I [" + id + "]:[" + hash + "] have the answer for [" + msg.tgtNode + "]:[" + msg.tgtHash + "]",
                            // default
                            proxyNode: msg.proxyNode, // next step intermediary, self // aki espodria estalviar pero es repetir codi ja ho tractara el loopback_dc
                            proxyStack: msg.proxyStack, // starting with current, afterward pop... pop
                            path: msg.path, // stack of route taken
                            hop: msg.hop,
                            // particular
                            sdp: pc[msg.srcNode].localDescription
                        };
                        // AKI
                        if (msg.srcNode === msg.tgtNode) { // localhost
                            handle_peer_answerResponse(msg);
                        } else {
                            send(msg.proxyNode, msg);
                        }
                        console.info(">>sendAnswer> COMPLETE & WAIT ");
                        clearInterval(myVar);
                    } else {
                        console.log("waiting iceGatheringState to complete");
                    }
                }, 2000);
            }
        }
        function handle_peer_answerResponse(msg) {
            try {
                msg = JSON.parse(msg);
            } catch (e) {
                console.info("LOCAL handle_peer_answerResponse");
            }
            console.log(msg);
            console.error("HANDLE_PEER_ANSWERRESPONSE: ");
            console.info(">>from: " + msg.srcNode);
            if (msg.srcNode === msg.tgtNode) { // localhost
                pc_loopback.setRemoteDescription(new RTCSessionDescription(msg.sdp), gotSetAnswer, gotError);
            } else {
                console.error("UPDATE " + msg.tgtNode + " REMOTE DESCRIPTION!");
                pc[msg.srcNode].setRemoteDescription(new RTCSessionDescription(msg.sdp), gotSetAnswer, gotError);
                console.log(pc[msg.srcNode].remoteDescription);
            }
            function gotSetAnswer() {
                console.info(">>recvAnswer> COMPLETE & WAIT ");
            }
        }


//////////////////////////////////////////////////////////// 
// JOIN TO OVERlAY BOOTSTRAPER - protected
        this.setup = function() {
            console.log("SETUP pc&dc");
            // requestRoom sdpOffer | be roomSubject
            socket.emit('setup');
            // invoke listeners 
            socket.on('offerRequest', function(targetSocket) { // SELF :D none needed
                console.log("offerRequest >> BOB: ");
                pc[targetSocket] = new RTCPeerConnection(pc_config);
                setPcHandlers(targetSocket);
                setDcHandlers(targetSocket, hash, dc_config);
                pc[targetSocket].createOffer(gotLocalOffer, gotError, ms_config);
                function gotLocalOffer(sdpOffer) {
                    console.error("UPDATE " + targetSocket + " LOCAL DESCRIPTION");
                    pc[targetSocket].setLocalDescription(sdpOffer, gotSetOffer, gotError);
                }
                function gotSetOffer() { // wait answer  
                    var myVar = setInterval(function() {
                        if (pc[targetSocket] && (navigator.mozGetUserMedia || pc[targetSocket].iceGatheringState === "complete")) {
                            socket.emit('offerResponse', targetSocket, pc[targetSocket].localDescription);
                            clearInterval(myVar);
                        }
                    }, 2000);
                }
            });
            socket.on('offerResponse', function(targetSocket, remoteOffer) {
                console.log("offerResponse >> ALICE: ");
                // console.log(remoteOffer.sdp);
                pc[targetSocket] = new RTCPeerConnection(pc_config);
                setPcHandlers(targetSocket);
                //  setDcHandlers(targetSocket, token, dc_config);
                pc[targetSocket].setRemoteDescription(new RTCSessionDescription(remoteOffer), gotCreateAnswer, gotError);
                function gotCreateAnswer() {
                    pc[targetSocket].createAnswer(gotLocalAnswer, gotError, {});
                }
                function gotLocalAnswer(sdpAnswer) {
                    console.error("UPDATE " + targetSocket + " LOCAL DESCRIPTION");
                    pc[targetSocket].setLocalDescription(sdpAnswer, gotSetAnswer, gotError);
                }
                function gotSetAnswer() {
                    var myVar = setInterval(function() {
                        console.log("isAnswerReady >> ALICE ");
                        if (pc[targetSocket] && (navigator.mozGetUserMedia || pc[targetSocket].iceGatheringState === "complete")) {
                            socket.emit('answerResponse', targetSocket, pc[targetSocket].localDescription);
                            console.log("ALICE >sendAnswer> COMPLETE & WAIT ");
                            clearInterval(myVar);
                        }
                    }, 5000);
                }
            });
            socket.on('answerResponse', function(targetSocket, remoteAnswer) {
                console.log("answerResponse >> BOB " + remoteAnswer);
                pc[targetSocket].setRemoteDescription(new RTCSessionDescription(remoteAnswer), gotSetAnswer, gotError);
                function gotSetAnswer() {
                    console.log("BOB >recvAnswer> COMPLETE & WAIT ");
                }
            });
        };

///////////////////////////
// HANDLERS PEER CONNECTION

        function gotError(error) {
            console.error(error);
            var text = "gotError: " + error.message;
            console.error(text);
        }

        function setPcHandlers(targetSocket) {
            pc[targetSocket].onaddstream = handleStreamAdded;
            pc[targetSocket].onremovestream = handleStreamRemoved;
            pc[targetSocket].onnegotiationneeded = handleOnNegotiationNeeded;
            pc[targetSocket].onicecandidate = handleIceCandidate; //
            pc[targetSocket].ondatachannel = handleDCJoin;
            pc[targetSocket].oniceconnectionstatechange = handleICEStateChange;
            pc[targetSocket].onsignalingstatechange = handleSignalStateChange;

            function handleIceCandidate(ice) {
                if (ice.candidate) {
                    var candidate = new RTCIceCandidate(ice.candidate);
                    pc[targetSocket].addIceCandidate(candidate);
                } else {
                    console.log("> LOCAL ICE READY >");
                }
            }

            function handleDCJoin(event) {
                console.error("DCJoin[" + event.channel.label + "].state is: [" + event.channel.readyState + "] to dcRemote");
                //	console.log("dc[" + targetSocket + "] has Joined!");
                dc[targetSocket] = event.channel;
                //	console.log('handleDCJoin. dcRemote: ', dc[targetSocket]);
                dc[targetSocket].onmessage = handleMessage;
                dc[targetSocket].onopen = handleDCStateChange;	// action listener cuan s'obre el canal 	    dc[targetSocket].onclose = handleDCStateChange; // action listener per cuan se tanca el canal 
                dc[targetSocket].onerror = handleDCError;
            }
        }

        function setPcLoopback() {
            pc_loopback.onaddstream = handleStreamAdded;
            pc_loopback.onremovestream = handleStreamRemoved;
            pc_loopback.onnegotiationneeded = handleOnNegotiationNeeded;
            pc_loopback.onicecandidate = handleIceCandidate; //
            pc_loopback.ondatachannel = handleDCJoin;
            pc_loopback.oniceconnectionstatechange = handleICEStateChange;
            pc_loopback.onsignalingstatechange = handleSignalStateChange;
            function handleIceCandidate(ice) {
                if (ice.candidate) {
                    var candidate = new RTCIceCandidate(ice.candidate);
                    pc_loopback.addIceCandidate(candidate);
                } else {
                    console.log("> LOOPBACK ICE READY >");
                }
            }

            function handleDCJoin(event) {
                console.error("DCJoin[" + event.channel.label + "].state is: [" + event.channel.readyState + "] to dcRemote");
                //	console.log("dc[" + targetSocket + "] has Joined!");
                dc_loopback = event.channel;
                //	console.log('handleDCJoin. dcRemote: ', dc[targetSocket]);
                dc_loopback.onmessage = handleMessage;
                dc_loopback.onopen = handleDCStateChange;	// action listener cuan s'obre el canal 	    dc[targetSocket].onclose = handleDCStateChange; // action listener per cuan se tanca el canal 
                dc_loopback.onerror = handleDCError;
            }
        }

        function setDcHandlers(targetSocket, token, dc_config) { // THIS IS THE CLIENT HANDLE MESSAGE
            dc[targetSocket] = pc[targetSocket].createDataChannel("dcToken[" + token + "]", dc_config);
            // start dc handlers 
            dc[targetSocket].onmessage = handleMessage;
            dc[targetSocket].onopen = handleDCStateChange;  // action listener cuan s'obre el canal
            dc[targetSocket].onclose = handleDCStateChange; // action listener per cuan se tanca el canal
            dc[targetSocket].onerror = handleDCError;
        }
        function setDcLoopback(dc_config, hash) {
            dc_loopback = pc_loopback.createDataChannel("dcToken[" + hash + "]", dc_config);
            dc_loopback.onmessage = handleMessage;
            dc_loopback.onopen = handleDCStateChange;  // action listener cuan s'obre el canal
            dc_loopback.onclose = handleDCStateChange; // action listener per cuan se tanca el canal
            dc_loopback.onerror = handleDCError;
        }
        function handleSignalStateChange(event) {
            //  console.log('handleSignalStateChange. Event: ', event);
        }
        function handleOnNegotiationNeeded(event) {
            //   console.log('handleOnNegotiationNeeded. Event: ', event);
        }
        function handleStreamRemoved(event) {
            console.log('handleStreamRemoved. Event: ', event);
        }
        function handleICEStateChange(event) {
            //   console.log('handleICEStateChange. Event: ', event);
        }
        function handleDCStateChange(event) {
            console.error("DC state is: " + event.target.readyState);
            console.log(event);
            // connection broken alert() if closed 
        }
        function handleDCError(err) {
            console.log('handleError. err: ', err);
        }
        function handleStreamAdded(event) {
            console.log('handleStreamAdded event', event);
        }
        function handleMessage(msg) { // ALWAYS STRINGIFY SO NONE OTHER WAY
            //  console.log("MSG RCV: ");
            //  console.log(msg.data);
            var data;
            try {
                data = JSON.parse(msg.data);
            } catch (e) {
                console.log("json.parseFAIL! " + e.message);
            }
            if (data.type === undefined) {
                console.log("MSG: " + data);
            } else {
                handle_rpc(data);
            }

        }
        ////////////////////////////////
        // FIN HANDLERS PEER CONNECTION



    }

//
// FIN NODE
//






    // ////// //
    // CLIENT //////////////////////////////////////////////////////////////////
    // ////// // Bootstraper 
    function xClient(socket) {
        var clientId; // identificador de node
        var leaderId;
        var room;

        this.setup = function() { // inicialitzar els listeners 

            socket.on('responseRooms', function(rooms) {
                console.log('responseRooms');
                // injectar-ho a la vista
                console.log(rooms);
            });

            socket.on('responseClients', function(clients) {
                console.log('responseClients');
                console.log(clients);
                for (index in clients) {
                    console.log(clients[index]);
                }
            });

            socket.on('responseJoinRoom', function(socketID, leaderID) {
                console.log('responseJoinRoom');
                console.log(socketID + ":" + leaderID);
                clientId = socketID;
                leaderId = leaderID;
            });

            socket.on('responseRoomLeader', function(leader, room) {
                console.log('responseRoomLeader');
                console.log("room: " + room + " leader is" + leader);
            });

            socket.on('message', function(key, value) {
                console.log('message');
                if ((key === undefined || value === undefined)) {
                    console.log("simple: " + key);
                } else {
                    console.log(key + ":" + value);
                    switch (key) {
                        case "leaderJoin":
                            console.warn("new Leader: " + value);
                            leaderId = value;
                            break;
                        case "leaderQuit":
                            console.warn("set request: " + value);
                            socket.emit('setup', room);
                            break;
                        case "idResponse":
                            console.info("get client id: " + value);
                            clientId = value;
                            break;
                        case "leaderResponse":
                            console.info("get leader id: " + value);
                            leaderId = value;
                            break;
                        default:
                            console.warn("missing key");
                            break;
                    }
                }
            });
        };

        this.connect = function(roomName) {
            this.setup();
            socket.emit('join', roomName);
            socket.emit('idRequest');
            socket.emit('leaderRequest');
            room = roomName;
        };

        this.reconnect = function() {
            socket.emit('setup');
        };

        this.getClientInfo = function() {
            console.log({client_id: clientId, leader_id: leaderId, room: room});
            return {client_id: clientId, leader_id: leaderId, room: room};
        };

        this.id = function() {
            return clientId;
        };

        this.bootId = function() {
            return leaderId;
        };

        this.bootStrapStatus = function() {
            socket.emit('idRequest');
            socket.emit('leaderRequest');
        };

    }
    ;

//
// FIN CLIENT
//




    // /////// // 
    // ADAPTER /////////////////////////////////////////////////////////////////
    // /////// //
    browser = {
        clave: "valor",
        mozilla: navigator.mozGetUserMedia,
        chrome: navigator.webkitGetUserMedia,
        opera: navigator.getUserMedia,
        explorer: navigator.msGetUserMedia,
        safari: "valorSafari"
    };

    // build it as a library 
    navigator.getMedia = (navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia);

    var RTCPeerConnection = null;
    var getUserMedia = null;
    var attachMediaStream = null;
    var reattachMediaStream = null;
    var webrtcDetectedBrowser = null;
    var webrtcDetectedVersion = null;
    var webrtcStunServer = "stun.l.google.com:19302";

    switch (navigator.getMedia) {
        case navigator.msGetUserMedia:
            console.log("microsoft internet explorer");
            //  none suported 
            setupExplorer();
            break;
        case navigator.mozGetUserMedia:
            console.log("mozilla firefox");
            webrtcDetectedBrowser = "firefox";
            webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]);
            setupFirefox();
            break;
        case navigator.webkitGetUserMedia:
            console.log("google chrome");
            webrtcDetectedBrowser = "chrome";
            webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2]);
            setupChrome();
            break;
        case navigator.getUserMedia:
            console.log("opera");
            webrtcDetectedBrowser = "chrome"; // opera use webkit :D
            webrtcDetectedVersion = parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2]);
            setupOpera();
            break;
        default:
            console.log("browser does not appear to be compatible with webrtc");
            // en aquest cas quan no ho soport mostra per log el primer que troba ;D
            break;
    }

    /** SETUP **/
    function setupChrome() {
        console.log("this appears to be chrome");
        createIceServer = function(url, username, password) {
            var iceServer = null;
            var url_parts = url.split(':');
            if (url_parts[0].indexOf('stun') === 0) {
                // create ice server with stun url 
                // perque no s'ha trobat cap candidat
                iceServer = {'url': url};
            } else
            if (url_parts[0].indexOf('turn') === 0) {
                if (webrtcDetectedVersion < 28) {
                    var url_turn_parts = url.split("turn:");
                    iceServer = {
                        'url': 'turn:' + username + '@' + url_turn_parts[1],
                        'credential': password};
                } else {
                    iceServer = {
                        'url': url,
                        'credential': password,
                        'username': username
                    };
                }
            }
            return iceServer;
        };

        // the RTC peer connection object
        RTCPeerConnection = webkitRTCPeerConnection;
        getUserMedia = navigator.webkitGetUserMedia.bind(navigator);

        // atach a media stream to an element 
        attachMediaStream = function(element, stream) {
            if (typeof element.srcObject !== 'undefined') {
                element.srcObject = stream;
            } else
            if (typeof element.mozSrcObject !== 'undefined') {
                element.mozSrcObject = stream;
            } else if (typeof element.src !== 'undefined') {
                element.src = URL.createObjectURL(stream);
            } else {
                console.log('Error attaching stream to element.');
            }
        };

        reattachMediaStream = function(to, from) {
            to.src = from.src;
        };

        if (!webkitMediaStream.prototype.getVideoTracks) {
            webkitMediaStream.prototype.getVideoTracks = function() {
                return this.videoTracks;
            };
            webkitMediaStream.prototype.getAudioTracks = function() {
                return this.audioTracks;
            };
        }
        // New syntax of getXXXStreams method in M26.
        if (!webkitRTCPeerConnection.prototype.getLocalStreams) {
            webkitRTCPeerConnection.prototype.getLocalStreams = function() {
                return this.localStreams;
            };
            webkitRTCPeerConnection.prototype.getRemoteStreams = function() {
                return this.remoteStreams;
            };
        }
    }

    function setupFirefox() {
        console.log("this appears to be firefox");
        webrtcStunServer = "74.125.31.127:19302";
        // The RTCPeerConnection object.
        RTCPeerConnection = mozRTCPeerConnection;

        // The RTCSessionDescription object.
        RTCSessionDescription = mozRTCSessionDescription;

        // The RTCIceCandidate object.
        RTCIceCandidate = mozRTCIceCandidate;

        getUserMedia = navigator.mozGetUserMedia.bind(navigator);

        // Creates iceServer from the url for FF.
        createIceServer = function(url, username, password) {
            var iceServer = null;
            var url_parts = url.split(':');
            if (url_parts[0].indexOf('stun') === 0) {
                // Create iceServer with stun url.
                iceServer = {'url': url};
            } else if (url_parts[0].indexOf('turn') === 0 &&
                    (url.indexOf('transport=udp') !== -1 ||
                            url.indexOf('?transport') === -1)) {
                // Create iceServer with turn url.
                // Ignore the transport parameter from TURN url.
                var turn_url_parts = url.split("?");
                iceServer = {'url': turn_url_parts[0],
                    'credential': password,
                    'username': username};
            }
            return iceServer;
        };

        // Attach a media stream to an element.
        attachMediaStream = function(element, stream) {
            console.log("Attaching media stream");
            element.mozSrcObject = stream;
            element.play();
        };

        reattachMediaStream = function(to, from) {
            console.log("Reattaching media stream");
            to.mozSrcObject = from.mozSrcObject;
            to.play();
        };

        // Fake get{Video,Audio}Tracks
        MediaStream.prototype.getVideoTracks = function() {
            return [];
        };

        MediaStream.prototype.getAudioTracks = function() {
            return [];
        };
    }

    function setupOpera() {
        // no setup needed, runs as defualt...
        console.log("none setup");
    }

    function setupExplorer() {
        console.warn("none supoirted");
    }

    if (window.File && window.FileReader && window.FileList && window.Blob) {
        console.log('FILE SHARE SUPPORTED!');
    } else {
        console.log('FS-NONE-SUPORTED');
        exit(0);
        // alert('FS-NONE-SUPORTED');
    }




    function time() {
        var currentdate = new Date();
        var datetime = "Last Sync: " + currentdate.getDate() + "/"
                + (currentdate.getMonth() + 1) + "/"
                + currentdate.getFullYear() + " @ "
                + currentdate.getHours() + ":"
                + currentdate.getMinutes() + ":"
                + currentdate.getSeconds();
        return datetime;
    }


})('Hello World :D');

chord.connect("SARAGOLD");
// chord.connect("chord_name", ["signal_server_url"]); // segon parametre és opcional  
 